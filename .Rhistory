librray(devtools)
library(devtools)
load_all()
data("sample_returns_small")
marg_input_sample_returns_small <- lazy_dt(sample_returns_small) %>%
mutate(row_num = seq.int(nrow(sample_returns_small))) %>%
pivot_longer(-row_num, names_to = "asset", values_to = "returns") %>%
data.table::as.data.table()
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
lazy_dt(sample_returns_small) %>%
mutate(row_num = seq.int(nrow(sample_returns_small))) %>%
pivot_longer(-row_num, names_to = "asset", values_to = "returns") %>%
data.table::as.data.table()
lazy_dt(sample_returns_small) %>%
mutate(row_num = seq.int(nrow(sample_returns_small))) %>%
pivot_longer(-row_num, names_to = "asset", values_to = "returns") %>%
select(asset) %>%
data.table::as.data.table()
debugonce(estimate_marginal_models)
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
roll@forecast$density %>%
dtplyr::lazy_dt()
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
select(Mu, Sigma, Realized, Shape, Skew)
library(data.table)
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
select(Mu, Sigma, Realized, Shape, Skew)
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
select(Mu)
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
mutate(mu = Mu)
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
head()
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
class()
library(btvine)
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
class()
roll@forecast$density %>%
dtplyr::lazy_dt() %>%
select(Mu)
#' @param all_asset_names character vector with all the asset names
#' @param marginal_specs_list named list containing the specification for the
#' marginal ARMA-GARCH model for each asset.
#' @param trace if set to TRUE the algorithm will print information while
#'  running.
#'
#' @return list with two elements: `roll_model_fit` this contains a list of all
#'
#' @import dplyr
#' @noRd
estimate_marginal_models <- function(
data,
n_all_obs, n_marg_train, n_marg_refit, n_vine_train,
all_asset_names,
marginal_specs_list,
trace
) {
# very basic input checks as the function will not be exported
checkmate::assert_data_table(data, any.missing = FALSE,
ncols = 3, col.names = "unique")
checkmate::assert_subset(colnames(data), c("asset", "returns", "row_num"),
empty.ok = FALSE)
checkmate::assert_subset(all_asset_names, unique(data$asset),empty.ok = FALSE)
checkmate::assert_list(marginal_specs_list, types = "uGARCHspec",
len = length(all_asset_names), any.missing = FALSE,
names = "unique")
if (trace) cat("Fit marginal models:\n")
garch_rolls_list <- sapply(all_asset_names, function(asset_name) {
if (trace) cat(asset_name, " (", which(asset_name == all_asset_names),
"/", length(all_asset_names), ") ", sep = "")
# fit the model in a rolling window fashion
roll <- rugarch::ugarchroll(
spec = marginal_specs_list[[asset_name]],
data = data[data$asset == asset_name, ]$returns,
forecast.length = n_all_obs - n_marg_train,
refit.every = n_marg_refit, refit.window = "moving",
keep.coef = TRUE, solver = "hybrid"
)
# extract the density parameters for the window [n_marg_train+1, n_all_obs]
roll_density_params <- roll@forecast$density %>%
dtplyr::lazy_dt() %>%
select(Mu, Sigma, Realized, Shape, Skew) %>%
mutate(row_num = seq(n_marg_train + 1, n_all_obs)) %>%
data.table::as.data.table()
# extract the conditional innovations distribution
roll_distribution <- roll@model$spec@model$modeldesc$distribution
# get the residuals for each window and store all relevant residuals
# for the current asset in one data.table whose columns are specified below
residuals_dt <- sapply(
seq.int(roll@model$n.refits),
function(window) {
# first get the fitted residuals
# extract the coefficients for the window
coefs <- roll@model$coef[[window]]$coef[, 1]
spec <- rugarch::ugarchspec(distribution.model = roll_distribution,
fixed.pars = coefs)
start_window <- 1 + n_marg_train - n_vine_train +
(window - 1) * n_marg_refit
end_window <- min(n_all_obs, n_marg_train + n_marg_refit * window)
window_returns <- data[asset == asset_name]$returns[seq(start_window,
end_window)]
filtered_model <- rugarch::ugarchfilter(
spec = spec,
data = window_returns,
out.sample = end_window - start_window + 1 - n_vine_train
)
fitted_residuals <- as.numeric(
rugarch::residuals(filtered_model, standardize = TRUE))
window_residuals_fitted <- data.table::data.table(
resid = fitted_residuals,
shape = coefs["shape"],
skew = coefs["skew"],
row_num = seq.int(start_window, start_window + n_vine_train - 1)
)
# now get the forecasted residuals and append the fitted residuals
roll_density_params %>%
dtplyr::lazy_dt() %>%
filter(row_num <= end_window & row_num >= (start_window + n_vine_train)) %>%
arrange(row_num) %>%
mutate(resid = (Realized - Mu) / Sigma) %>%
select(resid, shape = Shape, skew = Skew, row_num) %>%
data.table::as.data.table() %>%
rbind(window_residuals_fitted) %>%
dtplyr::lazy_dt() %>%
arrange(row_num) %>%
# now one has all needed standardized residuals for this window.
# Thus the transformed copula scale residuals are still appended using
# the skew and shape parameters as well as the marginal distribution
# as well as the asset name, the index of the marginal window and
# the used marginal distribution used for the fitting.
mutate(
marg_window_num = window,
asset = asset_name,
marg_dist = roll_distribution,
copula_scale_resid = rugarch::pdist(
distribution = roll_distribution,
q = resid, shape = shape, skew = skew)) %>%
data.table::as.data.table()
}, simplify = FALSE) %>%
# bind the per marginal window data.tables together (possible as the
# column marg_window_num ensures identifyabilty)
data.table::rbindlist()
list(residuals_dt = residuals_dt, roll_model_fit = roll)
}, simplify = FALSE, USE.NAMES = TRUE)
if (trace) cat("\n")
garch_rolls_list
}
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
rm(estimate_marginal_models)
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
library(devtools)
load_all()
data("sample_returns_small")
marg_input_sample_returns_small <- lazy_dt(sample_returns_small) %>%
mutate(row_num = seq.int(nrow(sample_returns_small))) %>%
pivot_longer(-row_num, names_to = "asset", values_to = "returns") %>%
data.table::as.data.table()
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
#' @param all_asset_names character vector with all the asset names
#' @param marginal_specs_list named list containing the specification for the
#' marginal ARMA-GARCH model for each asset.
#' @param trace if set to TRUE the algorithm will print information while
#'  running.
#'
#' @return list with two elements: `roll_model_fit` this contains a list of all
#'
#' @import dplyr
#' @noRd
estimate_marginal_models <- function(
data,
n_all_obs, n_marg_train, n_marg_refit, n_vine_train,
all_asset_names,
marginal_specs_list,
trace
) {
# very basic input checks as the function will not be exported
checkmate::assert_data_table(data, any.missing = FALSE,
ncols = 3, col.names = "unique")
checkmate::assert_subset(colnames(data), c("asset", "returns", "row_num"),
empty.ok = FALSE)
checkmate::assert_subset(all_asset_names, unique(data$asset),empty.ok = FALSE)
checkmate::assert_list(marginal_specs_list, types = "uGARCHspec",
len = length(all_asset_names), any.missing = FALSE,
names = "unique")
if (trace) cat("Fit marginal models:\n")
garch_rolls_list <- sapply(all_asset_names, function(asset_name) {
if (trace) cat(asset_name, " (", which(asset_name == all_asset_names),
"/", length(all_asset_names), ") ", sep = "")
# fit the model in a rolling window fashion
roll <- rugarch::ugarchroll(
spec = marginal_specs_list[[asset_name]],
data = data[data$asset == asset_name, ]$returns,
forecast.length = n_all_obs - n_marg_train,
refit.every = n_marg_refit, refit.window = "moving",
keep.coef = TRUE, solver = "hybrid"
)
# extract the density parameters for the window [n_marg_train+1, n_all_obs]
roll_density_params <- roll@forecast$density %>%
dtplyr::lazy_dt() %>%
select(Mu, Sigma, Realized, Shape, Skew) %>%
mutate(row_num = seq(n_marg_train + 1, n_all_obs)) %>%
data.table::as.data.table()
# extract the conditional innovations distribution
roll_distribution <- roll@model$spec@model$modeldesc$distribution
# get the residuals for each window and store all relevant residuals
# for the current asset in one data.table whose columns are specified below
residuals_dt <- sapply(
seq.int(roll@model$n.refits),
function(window) {
# first get the fitted residuals
# extract the coefficients for the window
coefs <- roll@model$coef[[window]]$coef[, 1]
spec <- rugarch::ugarchspec(distribution.model = roll_distribution,
fixed.pars = coefs)
start_window <- 1 + n_marg_train - n_vine_train +
(window - 1) * n_marg_refit
end_window <- min(n_all_obs, n_marg_train + n_marg_refit * window)
window_returns <- data[asset == asset_name]$returns[seq(start_window,
end_window)]
filtered_model <- rugarch::ugarchfilter(
spec = spec,
data = window_returns,
out.sample = end_window - start_window + 1 - n_vine_train
)
fitted_residuals <- as.numeric(
rugarch::residuals(filtered_model, standardize = TRUE))
window_residuals_fitted <- data.table::data.table(
resid = fitted_residuals,
shape = coefs["shape"],
skew = coefs["skew"],
row_num = seq.int(start_window, start_window + n_vine_train - 1)
)
# now get the forecasted residuals and append the fitted residuals
roll_density_params %>%
dtplyr::lazy_dt() %>%
filter(row_num <= end_window & row_num >= (start_window + n_vine_train)) %>%
arrange(row_num) %>%
mutate(resid = (Realized - Mu) / Sigma) %>%
select(resid, shape = Shape, skew = Skew, row_num) %>%
data.table::as.data.table() %>%
rbind(window_residuals_fitted) %>%
dtplyr::lazy_dt() %>%
arrange(row_num) %>%
# now one has all needed standardized residuals for this window.
# Thus the transformed copula scale residuals are still appended using
# the skew and shape parameters as well as the marginal distribution
# as well as the asset name, the index of the marginal window and
# the used marginal distribution used for the fitting.
mutate(
marg_window_num = window,
asset = asset_name,
marg_dist = roll_distribution,
copula_scale_resid = rugarch::pdist(
distribution = roll_distribution,
q = resid, shape = shape, skew = skew)) %>%
data.table::as.data.table()
}, simplify = FALSE) %>%
# bind the per marginal window data.tables together (possible as the
# column marg_window_num ensures identifyabilty)
data.table::rbindlist()
list(residuals_dt = residuals_dt, roll_model_fit = roll)
}, simplify = FALSE, USE.NAMES = TRUE)
if (trace) cat("\n")
garch_rolls_list
}
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
test_basic_marginal_models_est <- estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
test_basic_marginal_models_est$AAPL$roll_model_fit
class(test_basic_marginal_models_est$AAPL$roll_model_fit)
class(test_basic_marginal_models_est$AAPL$residuals_dt)
head(test_basic_marginal_models_est$AAPL$residuals_dt)
test_that("basic output types", {
for (i in seq(3)) {
expect_s4_class(test_basic_marginal_models_est[[i]]$roll_model_fit,
"uGarchroll")
expect_true(
checkmate::test_data_table(
test_basic_marginal_models_est[[i]]$residuals_dt,
ncols = 8
)
)
}
})
expect_s4_class(test_basic_marginal_models_est[[i]]$roll_model_fit,
"uGARCHroll")
test_that("basic output types", {
for (i in seq(3)) {
expect_s4_class(test_basic_marginal_models_est[[i]]$roll_model_fit,
"uGARCHroll")
expect_true(
checkmate::test_data_table(
test_basic_marginal_models_est[[i]]$residuals_dt,
ncols = 8
)
)
}
})
unique(test_basic_marginal_models_est$GOOG$residuals_dt$marg_window_num)
sort(unique(test_basic_marginal_models_est$GOOG$residuals_dt$marg_window_num))
test_that("basic checks on the datatable output", {
for (i in seq(3)) {
expect_equal(
sort(unique(
test_basic_marginal_models_est[[i]]$residuals_dt$marg_window_num
)),
1:5)
expect_true(
all(
test_basic_marginal_models_est[[i]]$residuals_dt$copula_scale_resid <= 1
)
)
expect_true(
all(
test_basic_marginal_models_est[[i]]$residuals_dt$copula_scale_resid >= 0
)
)
expect_true(
min(test_basic_marginal_models_est[[i]]$residuals_dt$row_num) == 651
)
expect_true(
max(test_basic_marginal_models_est[[i]]$residuals_dt$row_num) == 1000
)
}
})
expect_error(
estimate_marginal_models(
marg_input_sample_returns_small[, 1:2],
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
)
estimate_marginal_models(
marg_input_sample_returns_small[, 1:2],
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
expect_error(
estimate_marginal_models(
marg_input_sample_returns_small[, 1:2],
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
),
expect_error(
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
)
expect_error(
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = c("AAPL", "GOOG", "AMAZON"),
marginal_specs_list = list(
"AAPL" = default_garch_spec(),
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
)
expect_error(
estimate_marginal_models(
marg_input_sample_returns_small,
n_all_obs = 1000, n_marg_train = 750,
n_marg_refit = 50, n_vine_train = 100,
all_asset_names = unique(marg_input_sample_returns_small$asset),
marginal_specs_list = list(
"GOOG" = default_garch_spec(),
"AMZN" = default_garch_spec()
),
trace = TRUE
)
)
test()
library(btvine)
document()
rm(list = c("estimate_marginal_models"))
document()
test()
document()
load_all()
test()
document()
