# add id column
data <- data[, row_num := seq.int(nrow(data))]
return(data)
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
debugonce(estimate_risk_roll)
estimate_risk_roll(test_data)
data[, row_num := seq.int(nrow(data))]
data2 <- data[, row_num := seq.int(nrow(data))]
data <- data[, row_num := seq.int(nrow(data))]
data
data[, row_num2 := seq.int(nrow(data))]
data
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
data <- data[, row_num := seq.int(nrow(data))]
1
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
#data <- data[, row_num := seq.int(nrow(data))]
data
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
data <- data[, row_num := seq.int(nrow(data))]
data
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
data[, row_num := seq.int(nrow(data))]
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
data[, row_num := seq.int(nrow(data))]
data
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
use_package("dplyr")
use_package("dtplyr")
library(dtplyr, include.only = "lazy_dt")
library(dplyr)
library(dplyr)
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
data <- lazy_dt(data) %>%
mutate(row_num = seq.int(nrow(data))) %>%
data.table::as.data.table()
data
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
library(tidyr, include.only = "pivot_longer")
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
data <- lazy_dt(data) %>%
mutate(row_num = seq.int(nrow(data))) %>%
pivot_longer(-row_num, names_to = "asset", values_to = "returns") %>%
data.table::as.data.table()
data
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
library(tidyr)
estimate_risk_roll <- function(
data, # matrix, dataframe or data.table to store the assets in the columns (columns named) no missing values allowed must be imputed
weights = NULL, # corresponding weights of the assets (conditioning vars must have weight 0) nonnegative and named
marginal_settings = NULL, # containing the needed information for the garch fitting i.e. marginal models
vine_settings = NULL, # containing needed information for the vine fitting
alpha = 0.05, # a vector specifying the levels at which the risk measures should be calculated
risk_measures = c("VaR", "ES_mean"), # a character vector with valid choices for risk measures to compute
cond_vars = NULL, # colnames of the variables to sample conditionally from
n_samples = 1000, # number of samples to compute for the risk measure estimates
n_cond_samples = 100, # number of samples of the conditioning variables
seed = 2
) {
# Return also the total run time at the end
start_time <- Sys.time()
# Input checks ----------------------------------------------------------
# data argument
data <- try(data.table::as.data.table(data), silent = TRUE)
if ("try-error" %in% class(data)) {
stop("The <data> argument is not coercible to a data.table.")
}
checkmate::assert_data_table(data, any.missing = FALSE,
types = "numeric", col.names = "unique")
# cond_vars argument
all_asset_names <- colnames(data)
checkmate::assert_character(cond_vars, any.missing = FALSE, max.len = 2,
null.ok = TRUE)
checkmate::assert_subset(cond_vars, all_asset_names)
# weights argument
n_all_assets <- length(all_asset_names)
checkmate::assert_numeric(weights, lower = 0, any.missing = FALSE,
len = n_all_assets, names = "unique",
null.ok = TRUE)
checkmate::assert_subset(names(weights), all_asset_names)
if (any(weights[cond_vars] != 0 & !is.null(cond_vars))) {
stop("The weights of the conditioning variables must be 0.")
}
# alpha argument
checkmate::assert_numeric(alpha, lower = 0, upper = 1, any.missing = FALSE,
min.len = 1)
# risk_measures argument
checkmate::assert_subset(risk_measures, c("VaR", "ES_mean",
"ES_median", "ES_mc"))
# n_samples, n_cond_samples, seed arguments
checkmate::assert_integerish(n_samples, lower = 1)
checkmate::assert_integerish(n_cond_samples, lower = 1)
checkmate::assert_integerish(seed, lower = 1)
# marginal_settings and vine_settings
checkmate::assert_class(marginal_settings, "marginal_settings",
null.ok = TRUE)
checkmate::assert_class(vine_settings, "vine_settings",
null.ok = TRUE)
# Preparations for the overall algorithm -------------------------------
# add id column
data <- lazy_dt(data) %>%
mutate(row_num = seq.int(nrow(data))) %>%
pivot_longer(-row_num, names_to = "asset", values_to = "returns") %>%
data.table::as.data.table()
data
# Estimate the marginal models in a rolling window fashion -------------
# Estimate the dependence structure and the risk measures --------------
# by simulation in a rolling window fashion ----------------------------
}
estimate_risk_roll(test_data)
library(tidyr, include.only = "pivot_longer")
devtools::install_github("tidyverse/dtplyr")
